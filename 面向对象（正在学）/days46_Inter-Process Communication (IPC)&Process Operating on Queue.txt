# 2.4进程间不共享全局变量
# import time
# from multiprocessing import Process
# li = []
# def wdata():
#     for i in range(5):
#         li.append(i)
#         time.sleep(1)
#     print('写入的数据是：', li)
# def rdata():
#     print('读取的数据是：', li)
# # 1防止别人导入文件的时候执行main里面的方法
# # 防止Windows系统递归创建子进程
# if __name__ =='__main__':
#     wa = Process(target=wdata)
#     ra = Process(target=rdata)
#     wa.start()
#     wa.join()
#     ra.start()
# 3.进程间的通信
# q.put():嵌入数据
# q.get()：取出数据
# q.empty():判读队列是否为空
# q.qsize():返回当前队列包含的消息数量
# q.full():判断队列是否为空
# from queue import Queue
# # 初始化一个队列队形
# q = Queue(3)#最多可以接收三条消息，没写或者是负值就代表没有上限，直到内存的尽头
# q.put('学习py第1天')
# q.put('好好学习py')
# q.put('一定要坚持下去啊！')
# print(q.qsize())
# print(q.full())
# print(q.empty())
# print(q.get())#获取队列的一条消息，然后将其从队列中删除
# print(q.get())
# print(q.get())
# print(q.empty())
from multiprocessing import Process,Queue
import time
li = ['guigui','zz','hh']
def wdata(q1):
    for i in range(5):
        print(f'{i}已经被放入')
        q1.put(i)
        time.sleep(1)
    print('写入的数据是：', li)
def rdata(q2):
    while True:
        #判断是否为空,为空就退出循环
        if q2.empty():
            break
        else:
            print('取出数据：',q2.get())
    print('读取的数据是：', li)#打印全局变量li的副本
if __name__ =='__main__':#Python程序的入口点，确保代码只在直接运行该文件时执行
    #创建队列对象
    q = Queue()#创建共享队列 - 这是进程间通信的桥梁
    p1 = Process(target=wdata,args=(q,))#创建进程p1，让它执行wdata函数，并把队列q作为参数传递给它
    p2 = Process(target=rdata,args=(q,))
    p1.start()
    p1.join()#等待p1完成 - 主进程会在这里暂停，直到p1执行完毕
    p2.start()
# 1. from multiprocessing import Queue
# 用途：进程间通信 (Inter-Process Communication)
# 特点：可以在不同的进程之间安全地传递数据
# 底层机制：使用管道(Pipe)和序列化来跨进程传输数据
# 适用场景：多进程编程
# 2. from queue import Queue
# 用途：线程间通信 (Inter-Thread Communication)
# 特点：只能在同一个进程内的不同线程之间传递数据
# 底层机制：使用锁机制保证线程安全
# 适用场景：多线程编程
# 详细对比
# 特性	multiprocessing.Queue	queue.Queue
# 通信范围	  跨进程	            同进程内的线程间
# 内存空间	不同进程有独立内存	    同一进程共享内存
# 性能	      较慢（需要序列化）	较快（直接内存访问）
# 数据拷贝	 需要序列化/反序列化	直接引用（通常）
# 使用场景	     CPU密集型任务	I/O密集型任务