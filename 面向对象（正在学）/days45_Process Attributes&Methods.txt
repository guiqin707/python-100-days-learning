进程
# 1.1含义
# 是操作系统进行资源分配和调度的基本单位，是操作系统结构的基础
# 一个正在运行的程序或者软件就是一个进程
# 程序跑起来就成了进程
# 注意：进程里面可以创建多个线程，多线程也可以完成多任务
# 1.2进程的状态
# 1就绪状态：运行的条件都已经满足，正在等待cpu执行
# 2.执行状态：cpu正在执行其功能
# 3.等待（阻塞）状态：等待某些条件满足，如一个程序sleeo了，此时就处于等待状态
# import time
# print('guigui')#执行状态
# name = input('你的名字是：')#光标闪动，等待用户输入，处于等待状态
# print(name)
# time.sleep(1)#延迟一秒，等待（阻塞）状态
# 2进程语法结构
# multiprocessing模块提供了Process类代表进程对象
# 2.1Process 类参数
# 1.target：执行的目标任务名，即子进程要执行的任务
# 2.args：以元组的形式传参
# 3.kwargs：以字典的形式传参
# 2.2 常用的方法
# 1.start()：开启子进程
# 2.is_alive():判断子进程是否还活着，存活返回True，死亡返回False
# 3.join():主进程等待子进程执行结束
# 2.3常用的属性
# name:当前进程的别名。默认Process-N
# pid：当前进程的进程编号
import multiprocessing
import os
from multiprocessing import Process


# def sing():
#     #os.getpid():获取当前进程编号
#     #os.getppid():parent，获取当前主进程的编号
#     print(f'sing子进程编号：{os.getpid()}，父进程pid：{os.getppid()}')#父进程的id就是py文件主进程id
#     print('在唱歌')
# def dance():
#     print(f'dance子进程编号：{os.getpid()},父进程pid：{os.getppid()}')
#     print('在跳舞')
# if __name__=='__main__':
#     #创建子进程
#     #修改子进程名的第一种方式
#     p1 = Process(target=sing,name='子进程一')
#     p2 = Process(target=dance,name='子进程二')
#     #开启
#     p1.start()
#     p2.start()
#     #修改子进程名的第二种方式
#     p1.name = '子进程1'
#     p2.name = '子进程2'
#     #访问name属性
#     print(p1.name)
#     print(p2.name)
#     #查看子进程的进程编号
#     print(p1.pid)
#     print(p2.pid)
#     print(f'主进程pid：{os.getpid()},主进程的父进程pid：{os.getppid()}')
#win+r,输入cmd，命令提示符窗口输入tasklist可以查看电脑里面进程的命令
# Ctrl+shift+f 查找
# pycharm64软件进程编号就是主进程发父进程编号
def eat(name):
    print(f'{name}在干饭')
def sleep(name):
    print(f'{name}在睡觉')
if __name__ == '__main__':
    p1 = Process(target=eat,args=('guigui',))
    p2 = Process(target=sleep,kwargs ={'name':'guigui'})
    p1.start()
    p1.join()#主进程处于等待的状态，p1是运行状态
    p2.start()
    p2.join()
    print(p1.is_alive())
    print(p2.is_alive())
# 写在主进程中判断存活状态的时候需要加入join阻塞一下
# 核心原因：主进程和子进程是异步执行的
# join() 方法的作用是：阻塞主进程，直到调用它的子进程执行结束。
# 通过在 p1.start() 后立刻调用 p1.join()，确保了以下执行顺序：
# 主进程启动 p1。
# 主进程在 p1.join() 处等待，什么也不做。
# 子进程 p1 执行 eat('guigui')，执行完毕后，进程结束。
# 主进程的 p1.join() 等待结束，继续执行下一行代码（即启动 p2）。
# 同理，主进程等待 p2 执行完毕。
# 当主进程执行到 print(p1.is_alive()) 时，p1 和 p2 100%确定已经执行完毕并终止了，所以 is_alive() 一定会返回 False。
# 比喻：这就像你派了一个手下（子进程）去送信，然后你立刻打电话问“信送到了吗？”。他可能还在路上（True），也可能刚送到（False）。
# 而 join 就像是让你在办公室等着，直到手下回来亲口告诉你“任务完成”，这时你再打电话问，得到的答案才是确定的（False）。
# 1、主进程运行 if __name__ == '__main__': 下面的所有代码
# 2、子进程只运行 target 指定的函数（如 eat() 或 sleep()）
# 3、主进程和子进程是完全独立的，它们有各自的内存空间
# 4、主进程负责创建、启动、等待和监控子进程