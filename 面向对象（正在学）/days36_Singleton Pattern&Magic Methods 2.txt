通过__new__()
# 设计流程
# 1、定义一个类属性，初始值为None，用来记录单例对象的引用
# 2、重写__new__()方法
# 3、进行判断，如果类属性是None，把__new__()返回的对象引用保存进去
# 4、返回类属性中记录的对象引用
# class Singleton:
#     obj = None
#     def __new__(cls):
#         if cls.obj == None:
#             cls.obj =super().__new__(cls)
#         return cls.obj
#     def __init__(self):
#         print('这是__init__')
# s = Singleton()
# print(s)
# s1=Singleton()
# print(s1)
# 单例模式：每一次实例化所创建的对象都是同一个，内存地址都一样
# 通过导入模块实现单例模式
# 模块就是天然的单例模式
# 应用场景
# 1、回收站对象
# 2、音乐播放器
# 3、开发游戏软件   场景管理器
# 4、数据库配置，数据库连接池的设计
# 魔法方法&魔法属性
# 在py中__XX__()的函数叫做魔法方法，具有特殊功能
# __doc__:类、函数的描述信息
# 查看类的描述信息，必须是多行注释
# class A:
#     """这是一个类描述"""
#     pass
# print(A.__doc__)
# __module__：表示当前操作对象所在的模块
# # __class__：表示当前操作对象所在的类
# import pytest01
# b = pytest01.B()
# print(b)
# b.func()
# print(b.__module__)
# print(b.__class__)
# __str__():对象的描述信息
# 如果类中定义了此方法，那么打印对象的时候，默认输出该方法的返回值，也就是打印方法中return的数据
# 注意：__str__()必须要返回字符串
# class C:
#
#     def __str__(self):
#         return('这是str的返回值')
# c = C()
# print(c)
# __del__():析构函数，在程序结束时调用，或者正在删除某个对象时也会被调用
# __call__():使一个实例对象成为一个可调用对象，就像函数一样可以被调用
# 可调用对象：内置函数/函数/类都是可调用对象，凡是可以把一对()应用到某个对象身上都可以称之为可调用对象
# callable():判断一个对象是否是可调用对象
def func():
    print('hhh')
func()
print(callable(func))
class A(object):
    def __call__(self):
        print('这是__call__')
a = A()
a()#调用一个可调用的实例对象，其实就是在调用它的__call__()方法
print(callable(a))