from greenlet import greenlet
# import gevent
# import time
# 3、gevent：遇到IO操作使，会进行自动切换，属于主动式切换
# 注意：文件命名不要和第三方模块或者内置模块重名
# 3.1使用
# gevent.spawn(函数名)：创建协程对象
# gevent.sleep()：耗时操作
# gevent.join():阻塞，等待某个协程执行结束
# gevent.joinall():等待所有协程对象都执行结束再退出，参数是一个协程对象列表
# def sing():
#     print('在唱歌')
#     gevent.sleep(3)
#     print('唱完歌了')
# def dance():
#     print('在跳舞')
#     gevent.sleep(2)
#     print('跳完舞了')
# if __name__ == '__main__':
#     #1.创建协程对象
#     g1 = gevent.spawn(sing)
#     g2 = gevent.spawn(dance)
#     #2.阻塞，等待协程执行结束
#     g1.join()#等待 g1 协程完成
#     g2.join()
# 3.3gevent.joinall([])
# def sing(name):
#     for i in range(3):
#         gevent.sleep(2)
#         print(f'{name}在唱歌，又在练习唱歌的{i}天')
# if __name__ == '__main__':
#     gevent.joinall([
#         gevent.spawn(sing,'guigui'),
#         gevent.spawn(sing,'zz')
#     ])
# 等待列表中所有协程完成
# 在等待期间，允许所有协程并发执行
# 当 guigui 遇到 gevent.sleep(2) 时，它会让出CPU
# gevent 会自动切换到 zz 协程执行
# 当 zz 也遇到 sleep 时，它也会让出CPU
# 这样两个协程就实现了并发执行
# joinall():等待所有的协程都执行结束再退出
# 3.4monkey补丁：拥有在模块运行使替换的功能
# 导入模块
import gevent
import time
from gevent import monkey
monkey.patch_all()#将用到的time.sleep()代码替换成gevent里面的gevent.time()
# 注意：monkey.patch_all()必须要放在被打补丁者的前面
def sing(name):
    for i in range(3):
        time.sleep(2)
        print(f'{name}在唱歌，又在练习唱歌的{i}天')
if __name__ == '__main__':
    gevent.joinall([
        gevent.spawn(sing,'guigui'),
        gevent.spawn(sing,'zz')
    ])
# 4.总结
# 4.1线程是cpu调度的基本单位，进程是资源分配的基本单位
# 4.2进程、线程和协程对比
# 进程：切换需要的资源最大，效率最低
# 线程：切换需要的资源一般，效率一般
# 协程：切换需要的资源最小，效率高
# 4.3多线程适合IO密集型操作（文件操作、爬虫），多进程适合cpu密集型操作（科学计算。对视频进行高清解码、计算圆周率）
# 4.4进程、线程、协程都是可以完成多任务的，可以根据自己的实际开发的需要选择使用