3.生成器generator
# py中一边循环一边计算的机制，叫做生成器
# 3.1生成器表达式
# 列表推导式
# li = [i*5 for i in range(6)]
# print(li)
# gen = (i*5 for i in range(6))#把[]变成()就成了生成器表达式
# print(gen)
# print(next(gen))
# 3.2生成器函数
# py中，实验了yield关键字的函数就称之为生成器函数
# yield的作用
# 1.类似return，将指定或者多个值返回给调用者
# 2.yield造句一次返回一个结果，在每一个结果之间，挂起函数，执行next(),再重新从挂起点继续往下执行
# 是函数中断，并保存中断的状态
# def gen():
#     print('开始')
#     yield 1#返回一个1，并暂停函数，在此处挂起，下一次再从此处恢复运行
#     yield 2
#     yield 3
# gen1 = gen()
# print(next(gen1))
# def gen2(n):
#     li = []
#     # for i in range(n):
#     #     li.append(i)
#     a = 0
#     while a<n:
#         li.append(a)
#         a += 1
#     print(li)
# gen2(2)
# def gen2(n):
#     li = []
#     a = 0
#     while a<n:
#         li.append(a)
#         yield a
#         a += 1
#     print(li)
# for i in gen2(5):
#     print(i)
# # 使用了yield关键字的就是生成器函数
# def text():
#     yield 1
#     yield 2
#     yield 3
# print(text())
# te = text()  # 创建一个生成器对象并保存到变量te
# print(next(te))  # 从同一个生成器对象中取值
# print(next(te))  # 继续从同一个生成器对象中取值
# print(next(text())) # 新建一个生成器，从头开始，输出1
# print(next(text())) # 又新建一个生成器，从头开始，输出1
# 注意：生成器对象是独立的，每次调用生成器函数都会返回一个新的生成器对象，它们之间互不影响。
# 三者关系
# 1. 可迭代对象 (Iterable)
# 是什么：任何可以用 for 循环遍历的对象
# 特点：实现了 __iter__() 方法
# 可以被多次遍历
# for 元素 in 列表:  # 可以遍历
#     print(元素)
# 2. 迭代器 (Iterator)
# 是什么：负责逐个产生值的对象
# 特点：实现了 __iter__() 和 __next__() 方法
# 只能遍历一次（消耗性）
# 记住当前位置
# 3. 生成器 (Generator)
# 是什么：一种特殊的迭代器，用函数方式创建
# 特点：使用 yield 关键字
# 自动实现迭代器协议
# 惰性计算（用的时候才生成）
# 可迭代对象：能被循环的东西
# 迭代器：会"记住位置"的可迭代对象
# 生成器：用 yield 创建的迭代器
# 关系：可迭代对象>迭代器>生成器
# 可迭代对象 → 迭代器
# 列表 = [1, 2, 3]
# 迭代器 = iter(列表)
# # 函数 → 生成器（迭代器）
# def 生成函数():
#     yield 1
# 生成器 = 生成函数()  # 生成器就是迭代器